# TCP/IP网络详解

## 1.网络分层

![网络分层](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\网络分层.png)

知识总结:各层之间相互依赖，报文逐级包装传输，确保网络通信之间的可靠性，安全性——进程通信

## 2.HTTP理解

### 1.什么是HTTP？

```css
超文本:计算机早期只是简单的文字字符，现在文本逐渐演变成了视频，语音、图片等广义文本，在HTTP中，这些都属于文本内容，就也是超文本

传输：两点之间的通信

协议：协议双方之间的行为规范

综上所述：HTTP协议就是专门在计算机领域两点之间传输超文本数据的行为和约束
```

### 2.HTTP 常⻅的状态码，有哪些？

```css
1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body
数据。
「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽
是其中的⼀部分，也是服务器处理成功的状态。

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是重定
向。
「301 Moved Permanently」表示永久᯿定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
「302 Found」表示临时᯿定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动᯿定向新的 URL。
「304 Not Modified」不具有跳转的含义，表示资源未修改，定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓
存控制。

4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。
「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。
「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。
「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。
「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。
「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。
「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器
发⽣了错误。
「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意
思。
```

### 3.http 常⻅字段有哪些？

```css
host：发送请求是的服务器域名
Content-Length: 1000 返回数据的文本长度
Connection ：字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤ keep-alive
Content-Type ：⽤于服务器回应时，告诉客户端，本次数据是什么格式 text/html; charset=utf-8
Content-Encoding ：字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式 gzip
```

### 4.GET与POST请求的区别？

```css
GET：从服务器请求资源，可以使静态文本、页面、图片视频
POST：向URL指定的资源提交数据，数据放在报文的body中

/**
*二者是安全和幂等的吗？
*/
安全：是指请求⽅法不会「破坏」服务器上的资源
幂等：是多次执⾏相同的操作，结果都是「相同」的
GET：安全且幂等
POST：不安全且不幂等
```

### 5.HTTP1.1的优点以及体现

```css
1. 简单
HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习
和使⽤的⻔槛。
2. 灵活和易于扩展
HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定
义和扩充。
同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。
HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的
QUIC。
3. 应⽤⼴泛和跨平台
互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购
物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。

缺点：
无状态：每次操作都是单独的，无法记录状态，一旦涉及用户的相关操作，都需要验证状态  ————使用cookies记录状态
明文传输：传输都是以明文形式，容易造成信息窃取
不安全：
一、通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。
二、不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。
三、⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。
```

### 6.HTTP1.1的性能如何？

```
HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥
1.长连接 保持TCP连接状态，使用持久连接减轻服务器端的负载
2.管道网络传输 一个请求发出不必等待回应，可以接着发送第二个请求，减少整体响应时间
3.队头阻塞 
```

### 7.HTTPs与HTTP的区别

```css
1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在
TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之
后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
```

### 8.HTTPS解决了HTTP的哪些问题？

```css
1.窃听风险  ---混合加密 对称加密与非对称加密
2.篡改风险  ---摘要算法 对数据生成第一无二的指纹，用于校验数据完整性
3.冒充风险  ---数据证书 客户端想服务器索要公钥，使用公钥加密信息，服务器收到密文后，用自己的私钥进行解密

HTTPS建立连接的过程（四次通信）：
1.ClientHellow
2.ServerHellow
3.客户端回应
4.服务器的最后回应

知识点：HTTP1.1、HTTP/2、HTTP/3的演变以及优化
```

### 9.如何优化HTTP1.1

```css
可以从以下三方面考虑：避免请求、减少请求、压缩响应资源
一、避免请求
浏览器用户操作会发送大量相同请求，如果每次都去请求服务器资源，会造成大量资源消耗，可以通过cookies以及session分别在服务器以及浏览器设置资源缓存，当用户发送请求时，首先在本地cookies中寻找，若资源不存在或者是cookies，才会想服务器发起请求，从而减少资源浪费
二、减少请求次数
①将原本由客户端处理的重定向请求，交给代理服务器处理，减少重定向的次数
②将多个小资源合并成大资源再进行传输，较少HTTP请求次数以及TCP连接数以及头部开销，省去三次握手和慢启动的网络消耗
③按需访问资源，只访问用户看的到的资源，以此达到延时请求，减少请求次数
三、压缩响应资源
选择优秀的压缩算法，压缩传输的响应资源，提高传输效率
```

### 10.TLS握手过程

```css
1.客户端首先向服务器发送报文，报文内容包括客户端生成的TLS版本号、随机数、支持的密码套件列表
2.服务器收到客户端报文，确认版本号是否支持，同时生成一个随机数以及一个合适的密码套件，紧接着服务器为了证明自己的身份，会发送一个数字证书给客户端，最后告诉客户端，本次打招呼完毕
3.客户端验证服务器发送的数字证书，生成一个新的随机数，用服务器的RSA公钥加密该随机数并发送给服务器，服务器收到报文后使用RSA私钥解密随机数，双方根据三个随机数生成会话秘钥，他是对称秘钥，用于后续http请求/响应的数据加密解密，然后客户端发送一个使用会话秘钥加密的摘要信息给服务器，验证加密通信和之前的握手信息是否有效
4.服务端也是同样的操作，发送一个会话加密的信息给客户端，如果双方都没问题，则表示握手成功
```

## 3.TCP理解

### 3.1TCP三次握手及四次挥手

```css
TCP的基本认识：面向连接、可靠的、基于字节流的传输层通信协议
面向连接：一对一连接
可靠：无论网络发生怎样的链路变化，可以保证报文一定能到达接收端
字节流：消息没有边界。所以无论消息有多大都可以进行传输，并且消息都是有序的，同时会进行去重处理
建立一个TCP连接服务端和客户端要达成三个共识：socket、序列号、窗口大小
TCP如何确定一个可靠的连接：（四元组）源地址、源端口、目的地址、目的端口  最大TCP连接数 = 2*32+2*16=2*48次方
/**
*与UDP协议的关系
**/
UDP：不可靠、无连接，没有拥塞处理和流量控制、首部开销、传输方式、分片不同、服务对象不同


/**
*三次握手具体实现
**/
1.客户端生成一个随机序列号，并将SYN标记位置为1，发送SYN报文给服务端，该报文不包含应用层协议
2.服务端收到客户端的SYN报文后，初始化自己的序号，将此序号填入TCP首部的序号字段中，在确认应答字段中填入客户端序号+1，并将SYN和ACK字段置为1，发送报文给客户端
3.客户端收到服务器报文后，还要向服务器回应最后一个应答报文，首先将ACk字段置为1，其次确认应答字段将服务器发送的确认应答号+1；此时可以携带客户端发送到服务端的数据报文，发送给服务端，成功握手

/**
*为什么是三次握手？
**/
1.为了避免历史连接
网络情况错综复杂，在网络拥堵的情况下，可能后发送的请求会先到达服务端，此时客户端做序列号的校验，发现是历史连接则终止连接
2.同步双方初始化序列号
序列号是可靠传输的关键因素——接收方可以去除重复数据、可以使数据包有序、可以标记发送出去的数据包是否存在丢包
3.避免资源浪费
如果只有两次握手，当客户端的SYN请求连接在网络中阻塞，客户端没有接受到ACK报文，就会重新发送SYN，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，客户端会重新建立一个新的连接，从而造成建立很多冗余无效的连接

总结：TCP三次握手能防止历史连接的建立，减少双方不必要的资源开销，帮助双方同步序列化
```

![三次握手](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\三次握手.png)

### 3.2四次挥手

```css
四次挥手过程：
1.客户端将FIN位置为1，并发送报文给服务端
2.服务端收到客户端的中断连接标记，发送ACK为1的报文给客户端，服务器处理文数据后，也向客户端发送一个FIN指令，进入最后确认状态
3.客户端收到服务器的FIN报文后，回复服务器一个ACK确认应答报文，随后自动关闭连接
4.服务端收到客户端的确认应答报文后，关闭连接
/**
*注意：为什么回收需要四次？
**/
第一次客户端发送FIN报文，表示客户端不再发送数据，服务器接受客户端FIN报文，并发出ACK确认应答报文，等待服务器将本次连接数据包处理完毕，再向客户端发送FIN报文，表示服务端不再发送数据包，客户端接收服务端FIN报文后，向服务器发送ACK确认应答报文，并主动进入TIME——WAIT状态最终关闭连接
由上述可知：服务端需要完成数据的处理和发送，导致ACK与FIN不会同时发送，从而形成四次握手
TIME_wait 时间2MSL，保证服务端有因为延时到达的数据不能被接收，导致下一次相同端口打开收到的数据错误
```

![四次挥手](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\四次挥手.png)

### 3.3TCP如何进行socket编程

```css
客户端与服务器同时初始化socket，服务端进行绑定IP与端口，随后进入监听模式，服务端调用accept等待客户端连接，客户端connect,向服务器的地址和端口发起请求，客户端返回用于传输数据的socket的文件描述符

/**
*注意：监听的socket和真正用来传输数据的socket，是两个socket，一个叫监听socket，一个叫做已完成连接socket
**/
重点：客户端connect成功返回是在第二次握手，服务器accept成功返回是在三次握手成功之后
```

### 3.4TCP重传、滑动窗口、流量控制、拥塞控制

```css
1.重传机制：
常见的重传机制：超时重传、快速重传、SACK、D-SACK
①超时重传：在发送数据时，设置一个定时器，当超出指定时间时，没有收到对方的ACK确认应答，就会重发该数据
RTT：一个报文在网络中的往返时间    RTO时间应该略大于报文往返RTT时间 RTO过长导致效率低下，过短会增加网络堵塞，更多的超时，而更多的超时会导致更多的重发
存在问题：超时周期可能相对较长
②快速重传：不以时间为驱动，以数据为驱动，当收到三个相同ack报文时触发重传
存在问题：重传时是传之前的一个，还是重传所有的问题
③SACK（选择性确认）：在TCP头部选项字段中加一个SACK字段，可以将缓存的地图发送给发送方，发送方就知道那些数据丢失了，这样就只重选丢失的数据
④D-SACK：让发送方知道，是发出去的包丢了，还是接收方回应的ack包丢了，可以知道发送方的数据包被网络延迟了，可以知道网络中是不是把发送方的数据给复制了
2.滑动窗口：
传输方式的缺点：数据包往返时间越长，通信的效率就越低
引入窗口：在窗口大小范围内，无需等待确认应答，可以继续发送数据的最大值，若存在丢包现象，可在下一次ACK确认应答中进行确认
/**
*发送窗口使用三指针操作：SND.WND发送窗口的大小、SND.UNA已发送但未收到确认的第一个字节的序列号、SND.NXT表示未发送但是可发送范围的第一个字节的序列号
接收窗口使用二指针：RCV.WND表示接收窗口大小   RCV.NXT是一个指针，期待从发送方发送来的下一个数据字节的序列号
*/
3.流量控制：
滑动窗口是以字节码作为基本单元，所以通过滑动窗口的大小进行控制报文传输速率，从而达到流量控制的作用
/**
*操作系统与滑动窗口的关系：滑动窗口的字节数都是存放在操作系统的缓冲区内的，而操作系统的缓冲区会被操作系统调整
两种现象：
一是一直往返发送数据知道滑动窗口大小降为0，窗口关闭
二是操作系统直接减小缓冲区大小，但是发送方窗口还未被通知，又发送了超过窗口大小的数据报文，导致数据丢包
针对以上情况：TCP规定不允许同时减少缓存又收缩窗口，二是先采取收缩窗口，过段时间在减少缓存，从而避免丢包
**/
异常情况：如果接受方发送的窗口非0通知丢失，导致发送方一直等待，将会造成死锁现象； 二是糊涂窗口综合征
解决方案:
①TCP为每个连接设有一个定时器，当一方收到对方的零窗口通知，就启动持续计时器，若定时器超时，就会发送窗口探测报文，对方确认这个探测报文时，给出自己现在的接收窗口大小
②设置NAGle算法，做延时处理（避免发送小数据）它满足以上两个条件：窗口大小 >=MSS 以及收到之前发送数据的ack回包
4.流量拥堵：
目的：避免发送方的数据填满整个网络
引入拥塞窗口：根据网络的拥塞程度动态变化的  现在发送窗口的大小 = min(拥塞窗口，接收窗口)

/**如何知道当前网络出现拥堵？
发送方没有在规定时间内接收到ack应答报文，发生超时重传，就被认为出现了网络拥堵
**/
常见的拥塞控制算法有哪些？慢启动、拥塞避免、拥塞发生、快速恢复
慢启动：
初始化拥塞窗口大小为1，当接到ack确认应答报文之后，cwnd窗口大小+1，当确认应答报文逐渐增加时，拥塞窗口大小呈指数增长；当达到慢启动门限ssthresh（65535字节）状态变量，使用拥塞避免算法
拥塞避免：
当达到慢启动门限时，采用拥塞避免算法，将指数变化变成线性变化，降低发送速度
拥塞发生：
当网络出现拥塞状况时，开始出现丢包现象，这是会触发重传机制，进入拥塞发生算法
主要有两种重传拥塞发生算法：
超时重传拥塞发生：重置ssthresh = cwnd/2，cwnd = 1；再次进入慢启动状态  ————该算法太过激进
快速重传拥塞发生：重置cwnd = cwnd/2，ssthresh = cwnd
快速恢复：
前提是快速重传拥堵算法重置参数，将拥堵窗口 cwnd = ssthresh+3，重传丢失的数据包，如果再次受到重复的ack确认应答，cwnd+1.如果受到新数据的ack，将cwnd设置为第一步中的ssthresh值，因为收到新的ack报文代表数据都已收到，恢复过程结束，再次进入拥塞避免状态。
```

![拥塞控制](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\tcp拥塞控制.png)

### 3.5TCP抓包详解

3.5.1tcp三次握手异常情况分析

```css
1.客户端发送SYN报文丢失
出现情况：触发重传机制，重传超时RTT呈指数增长，达到最大默认重传次数tcp_syn_retries设定之后不再发送
2.服务器发送SYN+ACK报文丢失
出现情况：客户端以及服务端都会触发重传，服务器达到最大重传ACK报文次数tcp_synack_retries默认设定后不再发送
3.第三次客户端发送ACK报文丢失
出现情况：此时服务端与客户端其实已经建立连接，客户端在第三次握手时其实已经可以发送数据报文了，此时会出现两种状况，一是客户端有数据发送，ACk报文丢失情况下，触发数据重传，当达到最大次数tcp_retries2设定之后断开连接，二是无数据发送，此时客户端将会进入保活机制，每隔一段时间发送一次探测报文，当超过最大时间限制之后，中断本次连接
```

3.5.2tcp半连接队列和全连接队列

```css
SYN队列——半连接队列
accepet队列——全连接队列
/**
*
TCP运行机制：服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客
户端会返回 ACK，服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连
接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。
**/
压力测试：TCP全连接最大队列导致TCP全连接溢出被丢弃，可以跳大backlog以及somaxconn参数
情况：当服务端并发处理大量tcp请求时，全连接排列过小将会导致队列溢出，后续请求将会被丢弃，造成服务端请求数量上不去的现象（丢弃连接是Linux的默认行为，还可以选择向客户端发送RST复位报文，告诉客户端连接建立失败）
/**
*如何增大TCP全连接队列？
TCP 全连接队列的最⼤值取决于 somaxconn 和 backlog 之间的最⼩值，也就是 min(somaxconn, backlog)。
**/
总结：调整accept队列即增大全连接队列应该同时增大somaxconn与backlog的值

```

![1647074906(1)](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\1647074906(1).png)

### 3.6三次握手优化策略

![三次握手优化](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\三次握手优化.png)

### 3.7四次挥手的优化策略

![四次挥手的优化](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\四次挥手的优化.png)

### 3.8数据传输的优化

![数据传输的优化](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\数据传输的优化.png)

# 操作系统详解

## 1.基础硬件介绍

```css
1.CPU
有一组可以执行的特定指令集，与内存交互，从内存中提取指令并执行它
执行周期：提取一条指令、解码、并决定他的类型和操作数（循环往复）
内部包含一些寄存器：通用寄存器、程序计数器、堆栈指针、PSW程序状态字寄存器
①通用寄存器：保存关键变量和临时结果
②程序计数器：指示下一条需要从内存提取指令的地址，提取指令后将更新为下一条需要提取的地址
③堆栈指针：指向内存中当前栈的顶端，栈顶指针会包含输入过程中的有关参数，局部变量以及没有保存在寄存器中的临时变量
④psw状态字寄存器：它会跟踪当前系统的状态，用户程序可以读取整个psw，他在系统调用和I/o中起着重要作用
CPU设计：
在时间多路复用模式下——系统停止一个程序转而运行另一个程序，操作系统会保存所有寄存器的值
在流水线模式下——CPU具备可以同时读取多条指令的机制，且当CPU执行第N条指令时，还会解码第N+1条指令，还可以读取第N+2条指令
超标量CPU设计：
见下图————将多个执行单元解码放入缓冲区。直到缓冲区所有指令执行完成（指令顺序由硬件保证）
2.内存
存储层次结构：寄存器、高速缓存、主存、磁盘（由上而下，访问速度逐渐下降，容量逐渐扩大）
主存：RAM，易失型随机存取存储器，关机断电后丢失内容
非易失性随机存取存储器：ROM，一般用于启动计算机的引导加载模块（bootstrap）就存放在ROM中
EEPROM与闪存：属于非易失性，但是可以擦除和重写，速度介于RAM与磁盘之间
磁盘：
3.多线程和多核芯片
多线程允许CPU保持两个不同的线程状态并且在纳秒级的时间完成切换
多核芯片：在多内核CPU上有效承载了四个微型小芯片，每个微型芯片上都有自己的独立CPU
4.I/o设备
5.总线
```

![超标量CPU设计](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\超标量CPU设计.png)

## 2.进程

### 2.1伪运行

概念：是指单核或多核处理器同时执行多个进程，从而使程序更快，通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感

缺点：CPU时间可能分配给下一个进程，也可能不分配给下一个进程

### 2.2进程模型

```css
进程：计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程；一个进程就是一个正在执行的程序的实例
每个进程都有各自的虚拟的CPU，但是实际情况是CPU会在各个进程之间来回切换。
/**
*进程的创建：
  系统初始化——启动操作系统时，通常会创建若干个进程、有与用户交互的，也有运行在后台的，用于处理一些特定活动的叫做守护进程
  正在运行的程序执行了创建进程的系统调用（fork）
  用户请求创建一个新进程
  初始化一个批处理工作
*/

/**
*进程的终止：
正常退出：完成工作而终止
错误退出：发生严重错误而终止程序
严重错误：由进程引发的错误，通常是由于程序中的错误所导致的，例如，执行一条非法指令，引用不存在的内存
被其他进程杀死：某个进程执行系统调用告诉操作系统杀死某个进程
**/
进程态：运行态、就绪态、阻塞态  （阻塞态不能直接进入运行态、要经历就绪态的等待）
程序调度：决定那个进程优先被运行和运行多久
基于进程的操作系统最底层的是中断和调度处理，在该层之上是顺序进程

/**
*进程的实现：
操作系统为了维护进程间的切换，会维护一张表格——进程表，每个进程占用一个表项，该表项包含了进程状态的重要信息!
**/
```

![进程表项内容](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\进程表项内容.png)

### 2.3线程模型

```css
疑问：为什么有了进程之后还需要线程概念？
线程的使用：
1.多线程之间共享同一片地址空间和所有可用数据的能力，这是进程所不具备的，线程要比进程更轻量级，创建和撤销更简单
2.性能方面，如果多线程是CPU密集型，那么并不能获得性能上的增强，但如果存在大量计算和大量I/O处理，多线程在这些活动中可以重叠进行，加快应用程序的执行速度

/**
案例：web服务器的页面请求
*多线程解决方案：通过线程调度这个线程从网络中读取工作请求，在调度线程检查完请求后，选择一个空闲的工作线程来处理请求，将消息的指针写入到每个线程关联表的特殊字中，随后调度线程唤醒睡眠中的工作线程，将线程状态由阻塞态变为就绪态（这里有一层高速缓存作为优化）
单线程解决方案：阻塞式请求应答
有限状态机解决方案：在表中记录当前请求的状态，然后进入获取下一次事件，每次服务器从请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态
**/

经典的线程模型：一个进程中单个线程模型、一个进程中多个线程模型

线程系统调用：进程通常会从当前的某个单线程开始，然后这个线程通过库函数创建新的线程，当一个线程完成工作后，通过调用一个库函数（比如thread_exit）退出，紧接着线程消失，状态变为终止，不能再进行调度；
补充：thread_join表示一个线程可以等待另一个线程退出，thread_yield表示允许线程自动放弃CPU从而当另一个线程运行
POSIX线程——IEEE标准定义，一种独立于语言而存在的执行模型，以及并行执行模型
```

![线程模型](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\线程模型.png)

### 2.4线程实现

```css
1.实现方式
①用户空间内实现
②内核空间内实现
③用户和内核空间中混合实现
2.在用户空间内实现线程
把整个线程包放在用户空间，内核对线程一无所知，他不知道线程的存在
实现多线程：线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程：create、exit,join,yield，在用户管理线程时，每个线程都有一个其专用的线程表，用于追踪该进程中的线程，记录各个线程的属性
优势：
①在线程完成或是yield过程时，会涉及到进程线程切换，线程信息会被保留在运行时环境所提供的线程表中，所以启动他们比进行内核调用效率更高（不需要切换到内核，也不需要切换上下文，不会对告诉缓存进行刷新）；
②允许进程有自己定制的算法，用户线程的可拓展性较好，而且如果内核线程数量过多，容易出现问题
劣势：
①无法实现阻塞系统调用（缺页中断问题——跳转指令到了一条不在内存的指令上）
②一个线程开始运行，该线程所在进程中的其他线程都不能运行，除非自愿放弃CPU，在单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程
3.在内核中实现线程
不需要运行时环境，直接在内核中维护线程表和进程表，所有能够阻塞的调用都会通过系统调用的方式来实现；由于在内核中创建和销毁线程造成的开销比较大，所以系统会采用可循环利用的方式来回收线程
4.混合使用
将用户级线程和内核级线程多路复用起来，在这种模式中，编程人员可以自由控制用户级线程和内核级线程的数量，具备很大的灵活性

```

### 2.5进程间通信（IPC）

```css
三个问题：
1、一个进程如何传递消息给其他进程
2、如何确保两个两个或者多个线程之间不会互相干扰
3、数据的先后顺序问题
（后面两个问题同样适用于线程）
/**
*预备知识：
竞态条件：两个或者多个线程同时对一共享数据进行修改，从而影响程序运行的正确性
临界区：对共享内存进行访问的程序片段
互斥条件：禁止一个或多个进程在同一时刻对共享资源（共享内存，共享文件等）进行读写
**/
通信方式：
1.信号量：
2.管程：任何时候管程中只有一个活跃的进程，所以管程能够很方便的实现互斥操作，通过临界区自动互斥，管程比信号量更容易保证并行编程的正确性
3.java的管程实现：没有内嵌的条件变量，提供了wait和notify方法等价sleep()与wakeup()
4.消息传递：（针对不同机器上的通信状况）使用send()与receive()原语，发送者send消息，接受者receive消息
区分新老消息：每条消息都会嵌入一个原始序列号，通过比较原始序列号判断

```

### 2.6进程调度

```css
1.调度算法分类：批处理、交互式、实时
批处理中的调度：先来先服务、最短作业优先、最短剩余时间优先
交互式系统中的调度：时间片轮询调度（设置时间片长度必须合适）、优先级调度（按优先级切换进程，优先级高的分配时间片少，反之则多）、最短进程优先、保证调度、彩票调度、公平分享调度
实时系统中的调度：硬实时、软实时系统；实时系统的调度算法可以是静态的或动态的，前者在开始运行之前作出调度决策、后者在运行过程进行调度决策，所以静态调度的决策需要提前掌握所完成工作以及满足的截止时间等
/**
*调度策略和机制：
一个进程可能会包含多个子进程，主进程可能掌握哪一个子进程重要，而调度程序很少能够做出最优选择
解决办法：调度策略和调度机制分离——调度算法参数化，由用户进程输入参数，调度策略由用户进程决定
**/
线程调度：
```

## 3.内存

### 3.1分层存储器体系

```css
寄存器、高速缓存、主存、磁盘
发展过程：
无存储器抽象：每个程序直接访问物理地址，这种情况下不可能会有两个应用程序同时运行
运行多个程序：将当前内存中所有内容保存到磁盘空间中，然后再把程序读入内存中即可
物理内存暴露的存在问题：
①用户可以寻址内存中的每个字节，很容易破坏操作系统
②这种模式想运行多个程序非常困难
解决方式：保护、重定位——保护密钥标记内存块、地址空间（存储器抽象）
基址寄存器和变址寄存器：动态重定位——将每个进程的地址空间映射到物理内存的不同区域
基址寄存器：存储数据内存的起始位置
变址寄存器：存储应用程序的长度
寄存器地址比较：判断应用程序是否出错，因为没有进程都分配了一个私有地址，只有操作系统可以修改这二者的值
空闲内存管理：两种监控内存使用的方式——位图、空闲列表
位图：内存可能被划分为小到几个字或大到几千字节的分配单元，0-空闲，1-占用
链表管理：维护一个记录已分配内存段和空闲内存段的链表
为创建进程分配内存的算法：首次适配（沿段列表搜索，第一个足够大的空闲区）、最佳适配（最小且合适的空闲区）、最差适配、快速适配
```



![内存增大处理](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\内存增大处理.png)

### 3.2虚拟内存

```css
虚拟内存：每个程序都有自己的地址空间，这些地址空间被划分为多个称为页面的块，每一页都是连续的地址范围，这些页被映射到物理内存上
分页技术：使用MOV REG 1000命令将内存地址为1000de 内存单元的内容复制到REG中，地址可以通过索引，基址寄存器、段寄存器或其他方式产生（虚拟地址）
转换检测缓冲区（相联存储器TLB）：将虚拟地址直接映射到物理地址上，理论上讲就是一种内存缓冲
TLB加速分页
针对大内存的页表：
一、多级页表
一种分页方案，由两个或者多个层次的分页表组成，也称为分层分页，最后一页表存储的是实际信息
二、倒排页表
实际内存中的每一个页框对应一个表项，而不是虚拟页面对应的表项
页面置换算法：发生缺页异常时，操作系统会选择一个页面进行换出从而为新进来的页面腾出空间。如果要换出的页面在内存中已经被修改，那么必须将其写到磁盘中以使磁盘副本保持最新状态
常见的页面置换算法：
1.最优页面置换算法
2.最近未使用页面置换算法
3.先进先出页面置换算法
4.第二次机会页面置换算法
5.时钟页面置换算法
6.最近最少使用页面置换算法（LRU）
7.软件模拟LRU——NFU
8.工作集页面置换算法
9.工作集时钟页面置换算法
```

![页面置换算法总结](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\页面置换算法总结.png)

## 4.文件系统

### 4.1基础概念

```css
文件：一种抽象机制，它提供了一种方式用来存储信息以及后面进行读取，可能任何一种机制最重要的特性就是管理对象的命名方式
文件命名：现代操作系统一般命名规则都允许1-8个字母的字符串作为合法文件名 UNIX区分大小写，MS_DOS不区分
文件结构：1.字节序列 2.记录序列 3.树
文件类型：常规文件一般包括可执行文件、文本文件、图像文件（ASCII码或者二进制文件）
文件访问：序列访问、随机访问文件（两种读文件的方式：read从头开始读、seek设置当前位置，从当前位置开始读）
文件属性：元数据——文件创建日期、文件大小等属性  文件属性的状态——设置、清除
文件操作：Create、Delete、Open、Close、Read、Write、append、seek、get attributes、set attributes,rename
文件目录：一级目录系统、层次目录系统、
```

### 4.2文件系统的实现

```css
文件系统布局：文件系统存储在磁盘上、磁盘分区（或者叫磁盘分片）
文件的实现：连续分配、链表分配、索引分配
连续分配：使用连续的内存空间存储文件
优点：（简单、高性能）存储实现起来比较简单，只需要记住两个数字就可以了，一个是第一个快的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号，第二就是读取性能比较强，可以通过一次操作从文件中读取整个文件
链表分配：以磁盘块的链表形式存储文件，每个块的第一个字节作为指向下一块的指针，块的其他部分存放数据
```

# 计算机基础（硬件知识）

## CPU初识

```css
CPU概念：电脑核心组件，决定电脑的计算能力；CPU的核心是从程序或应用程序获取指令并执行计算，此阶段分为：提取、解码和执行。CPU负责解释和运行最终转换机器语言的内容
/**
内部结构分为两部分：
控制单元：从内存中提取指令并解码执行
算数逻辑单元：处理算数和逻辑运算
**/
从功能上来看：分为寄存器、控制器、运算器和时钟，各部分之间通过电信号连通
CPU是寄存器的集合体：累加寄存器、标志寄存器、程序寄存器、基址寄存器、变址寄存器、通用寄存器、指令寄存器、栈寄存器
/**
注意：程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器只有一个，其他寄存器一般有多个
**/
程序计数器：用于存储下一条指令所在单元的地址
/**
条件分支与循环机制的寄存器运行模式：
顺序结构：程序寄存器值加一
条件和循环分支：可以使程序计数器的值指向任意地址。使用jump（跳转指令）可以跳转到任意位置（可以使对象存储地址或者函数地址）
**/
标志寄存器：无论累加寄存器的运算结果是正数、零、负数，都会存储到标志寄存器中，标志寄存器的后三位分别为1代表正数、零、负数
/**特别提示：比较运算的本质是减法运算，将减法所得结果存储在标志寄存器中**/
函数调用机制：call与return指令
call指令会把调用函数后要执行的指令地址存储在栈主存中，函数处理完成之后，再通过函数出口来执行return指令；
return指令的作用是把保存在栈中的地址设定到程序计数器。
注意：先执行的call指令地址是存储到栈中的，运算完成之后，通过return指令将结果放入程序计数器中。
函数本身也是存储在程序计数器某个位置上，通过jump()跳转到函数运行位置
地址与索引实现数组：（基址寄存器、变址寄存器）
CPU指令执行过程：取指令、指令译码、执行指令、访问取数、结果写回
```



![CPU图解函数调用](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\CPU图解函数调用.png)

## 内存初识

```css
主要分为：RAM（随机存储器）-支持读写数据、ROM（只读存储器）——支持读、高速缓存——读写速度比内存更快的存储器
读写过程：如下图所示  —— 现实模型：根据字节数限制依次存储数据，可想象成一个数据占用多少楼层
数组、栈、队列、链表、二叉树都可以操作内存的读写，内存支持相应的特征操作
/**
注意：队列分为顺序队列与循环队列，循环队列一般是以环形缓冲区实现
**/
为什么要使用二进制：基于IC硬件特征，IC所有引脚只有两种电压：0v和5v，使得信息处理方式只能用0和1表示，也就是二进制表示。
移位运算与乘除的关系：左移-乘2，右移-除2
一个数的相反数：原数的补码  当运算结果为负数时，可以对结果进行取反加1。求补码操作
正数的逻辑右移左边补0，负数的逻辑算数左边补0  主要看正负数的值；左移——低位补0即可
/**
压缩算法介绍：
(1):RLE算法：AAAAAABBCDDEEEEEF -> A6B2C1D2E5F1 转换思路：字符*重复次数
(2):莫尔斯编码：频率最高的字符使用短编码，假设：断点——1，时间间隔-0，长点-11
(3):哈夫曼算法：二叉树哈夫曼算法，根据频率建立哈夫曼二叉树，进行编码
**/
```

![内存IC读取数据和写入数据](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\内存IC读取数据和写入数据.png)

![内存现实模型](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\内存现实模型.png)

## 磁盘初识

```css
磁盘构建介绍：
（1）：磁盘缓存——将磁盘经常读取的数据放入磁盘缓存，实现高速读取
（2）：虚拟内存：把磁盘的一部分作为假想内存来使用 在内存溢出的情况下，将虚拟内存与内存空间进行置换，实现超负荷运行
/**
虚拟内存与内存的交换方式：分页式和分段式
Windows采用的是分页式：如下图所示
**/
节约内存：增加内存容量，减小应用程序大小
（1）动态链接库：使用DLL文件——实现函数共有（多个程序使用相同函数功能时，可实现函数共有，减少资源浪费）
（2）_stdcall——反复调用方法:通过统一调用_stdcll函数执行栈清理工作，栈清理开销较小
磁盘物理结构：磁盘存储数据的形式 物理划分方式主要有两种：可变长方式和扇形方式
Windows主要采用扇形方式——分为扇区、扇面、磁道、簇
不同的文件不能存在在同一个簇中，否则将会导致文件不可删除，簇和扇区的大小是相等的
```

![虚拟内存置换](C:\Users\pc\Pictures\Saved Pictures\基础知识图解\虚拟内存置换.png)方法

## 操作系统环境

```css
运行环境 = 操作系统 + 硬件
不同操作系统的api差异性
FreeBSD操作系统详解：
Ports机制：将应用程序编译成对应系统源代码，如果源码在硬件上找不到，则会通过FTP请求到相应网站下载代码
虚拟机获取其他环境：提供相同运行环境的java虚拟机（运行环境），java虚拟机是一边把java字节代码逐一转换为本地代码一边在运行着。
系统调用和编程语言的移植性：
操作系统控制硬件的功能：这些函数以及调用函数的行为称为——系统函数，也就是应用进而调用操作系统的意思。应用程序是通过系统调用，磁盘抽象来实现对硬盘的控制。
```

## 应用和硬件的关系

```css
1.Windows使用系统调用实现对硬件的控制，系统调用称为API，API就是应用调用的函数，这些函数实体被存放在DLL文件
2.支持硬件输入输出的IN指令和OUT指令——I/O设备有自己用于临时保存数据的内存，这个内存就是端口，也称为寄存器
一个I/O控制器可以控制多个设备，各端口之间通过端口号进行区分，端口号被称为I/O地址
3.DMA机制——不通过cpu作为中介传输数据，直接读取内存的数据
```



